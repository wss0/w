<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
   <script>
       // 作用域：全局作用域，私有作用域
        // 全局作用域：
        // 当你打开一个页面，浏览器就会形成全局作用域为代码执行提供环境，在全局作用域在会生成一个全局的大对象叫window
        // 全局作用域一般不销毁，直到页面关闭，作用域才会销毁

        // 全局变量:
        // 在全局作用域下声明的变量就是全局变量

         // 1、用var和function声明的变量会在全局作用域下声明一个变量，而且也会给window增加属性，属性名是变量名，
         //   属性值是变量名存储的值（let不支持）
      
        // 2、var和function可以重复创建同一个变量名(let不可以)

        // 私有变量
        // 在私有作用域里边定义的变量就是私有变量（let、var、function、const）
        // 形参也是私有变量
        // 在私有作用域里使用一个变量，如果自己私有作用域有，就是用自己的，如果没有呢，就是用上一级作用域的
        // 函数外边不能拿到函数里边的变量


        
         // 变量提升
        // 变量提升就是浏览器解析代码的一个过程
        // 在当前作用域中，代码执行形之前，浏览器会对当前作用域里的带var和function进行提前的声明和定义；
        //带var的只声明（创建变量）不定义；带function既声明（创建变量）又定义（进行赋值）



        // 函数的作用域查找
        // 函数的上一级作用域是谁，在函数定义的时候就已经确定了，函数在哪创建的，他的上一级作用域就是谁，
        //跟在哪执行的没有关系

        // 作用域链查找机制
        // 在私有作用域中，函数执行，如果要使用一个变量，自己作用域要是有，就使用自己的，要是没有，就向上一级作用域查找，上一级还没有，在向上一级查找，直到找到全局作用域，
        //如果还没有就报错--->这种一级一级向上查找的机制就是【作用域链查找机制】


       // 闭包=>函数执行形成的私有作用域就是闭包，他可以保护里边的私有变量不受外界干扰，
        // 还可以保存变量
        

        //if里面的函数声明特殊情况

        // 1、变量提升发生在等号左边
        
        //2、不管if条件是否成立，都要进行变量提升

        // console.log(num) // undefined
        // if(false){
        //     var num = 12;
        // }
        // console.log(num) // undefined

        // console.log(fn); // undefined
        //      // 在老版本浏览器里，if条件里的function既声明又定义，
        //     // 在新版本浏览器里，if条件里的函数只声明不定义
        // if(false){
        //     // 条件一旦成立，第一件事就是给函数名赋值
        //     fn()
        //     function fn(){}
        // }
        // console.log(fn) // undefined

     

      // function fn(){
            // 函数定义：
            // 1、首先开辟一个堆内存生成一个16进制的空间地址
            // 2、把函数体里的代码以字符串的格式存储进去
            // 3、把16进制的地址赋值给函数名
       // }

       // fn()
        // 函数执行：
        // 1、首先开辟一个私有作用域【为代码执行提供环境】
        // 2、形参赋值
        // 3、变量提升
        // 4、代码从上往下执行
        // 5、作用域是否被销毁
   
    // fn()
    // function fn(){console.log(1)}
    // fn()
    // function fn(){console.log(2)}
    // fn()
    // var fn = function(){console.log(3)}
    // fn()
    // function fn(){console.log(4)}
    // fn()
    // function fn(){console.log(5)}

    // console.log(a, b, c);
    //     var a = 12,
    //         b = 13,
    //         c = 14;

    //     function fn(a) {
    //         console.log(a, b, c);
    //         a = 100;
    //         c = 200;
    //         console.log(a, b, c);
    //     }
    //     b = fn(10);

    //     console.log(a, b, c);
    // var i = 5;
    //     function fn(i) {
    //         return function (n) {
    //             console.log(n + (++i));
    //         }
    //     }
    //     var f = fn(1);
    //     console.log(f);
   
    var i = 5;
        function fn(i) {
            return function (n) {
                console.log(n + (++i));
            }
        }
        var f = fn(1);//function (n) { console.log(n + (++i));} 
        f(2);
        fn(3)(4);
        fn(5)(6);
        f(7);
        console.log(i);
   </script>
</body>
</html>